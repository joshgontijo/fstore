diff --git a/core/src/main/java/io/joshworks/fstore/core/io/buffers/Buffers.java b/core/src/main/java/io/joshworks/fstore/core/io/buffers/Buffers.java
index 4bf11893..660f8e40 100644
--- a/core/src/main/java/io/joshworks/fstore/core/io/buffers/Buffers.java
+++ b/core/src/main/java/io/joshworks/fstore/core/io/buffers/Buffers.java
@@ -70,6 +70,42 @@ public class Buffers {
         return i;
     }
 
+    public static int copy(ByteBuffer src, int srcOffset, int srcCount, ByteBuffer dst, int dstOffset) {
+        if (srcCount == 0) {
+            return 0;
+        }
+        if (srcOffset < 0 || srcOffset > src.capacity()) {
+            throw new IndexOutOfBoundsException(srcOffset);
+        }
+        if (srcCount > src.capacity() - srcOffset) {
+            throw new IndexOutOfBoundsException("srcCount bytes is more than available from srcOffset position");
+        }
+
+        if (srcCount > dst.remaining()) {
+            throw new BufferOverflowException();
+        }
+
+        int i = 0;
+        while ((srcCount - i) >= Long.BYTES) {
+            dst.putLong(dstOffset + i, src.getLong(srcOffset + i));
+            i += Long.BYTES;
+        }
+        while ((srcCount - i) >= Integer.BYTES) {
+            dst.putInt(dstOffset + i, src.getInt(srcOffset + i));
+            i += Integer.BYTES;
+        }
+        while ((srcCount - i) >= Short.BYTES) {
+            dst.putShort(dstOffset + i, src.getShort(srcOffset + i));
+            i += Short.BYTES;
+        }
+        while ((srcCount - i) >= Byte.BYTES) {
+            dst.put(dstOffset + i, src.get(srcOffset + i));
+            i += Byte.BYTES;
+        }
+
+        return i;
+    }
+
     /**
      * Copies remaining bytes from src to the dst
      * Does not modify source's position
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/Record2.java b/indexed-log/src/main/java/io/joshworks/ilog/Record2.java
index ff0162c6..06bd950b 100644
--- a/indexed-log/src/main/java/io/joshworks/ilog/Record2.java
+++ b/indexed-log/src/main/java/io/joshworks/ilog/Record2.java
@@ -4,6 +4,10 @@ import io.joshworks.fstore.core.Serializer;
 import io.joshworks.fstore.core.io.ChecksumException;
 import io.joshworks.fstore.core.io.buffers.Buffers;
 import io.joshworks.fstore.core.util.ByteBufferChecksum;
+import io.joshworks.ilog.fields.BlobField;
+import io.joshworks.ilog.fields.ByteField;
+import io.joshworks.ilog.fields.IntField;
+import io.joshworks.ilog.fields.LongField;
 import io.joshworks.ilog.index.KeyComparator;
 
 import java.io.IOException;
@@ -39,6 +43,14 @@ public class Record2 {
     public static final int KEY_LENGTH_OFFSET = ATTR_OFFSET + ATTR_LEN;
     public static final int KEY_OFFSET = KEY_LENGTH_OFFSET + KEY_LEN_LEN;
 
+    public static final IntField VALUE_LEN = new IntField(0);
+    public static final IntField CHECKSUM = new IntField(4);
+    public static final LongField TIMESTAMP = new LongField(8);
+    public static final ByteField ATTRIBUTE = new ByteField(16);
+    public static final IntField KEY_LENGTH = new IntField(17);
+    public static final BlobField KEY = new BlobField(21, KEY_LENGTH::get);
+    public static final BlobField VALUE = BlobField.after(KEY, VALUE_LEN::get);
+
 
     public static int valueSize(ByteBuffer buffer) {
         return buffer.getInt(relativePosition(buffer, DATA_LENGTH_OFFSET));
@@ -136,40 +148,24 @@ public class Record2 {
         return Buffers.copy(record, absValPos, valueSize(record), dst);
     }
 
-    public static int create(ByteBuffer key, ByteBuffer value, ByteBuffer dst, int... attributes) {
+    public static int create(ByteBuffer key, ByteBuffer value, ByteBuffer dst, int... attr) {
         if (dst.remaining() <= HEADER_BYTES) {
             throw new IllegalArgumentException("Write buffer must be at least " + HEADER_BYTES);
         }
-        try {
-            int recordStart = dst.position();
-            int originalLimit = dst.limit();
-            dst.position(HEADER_BYTES);
-            int keyStart = dst.position();
-            Buffers.copy(key, dst);
-            int keyEnd = dst.position();
-
-            int checksum = ByteBufferChecksum.crc32(value);
-            Buffers.copy(value, dst);
-            int dataEnd = dst.position();
-
-            int keyLen = keyEnd - keyStart;
-            int dataLen = dataEnd - keyEnd;
-
-            dst.position(recordStart);
-
-            dst.putInt(dataLen);
-            dst.putInt(checksum);
-            dst.putLong(System.currentTimeMillis());
-            dst.put(attribute(attributes));
-            dst.putInt(keyLen);
-
-            dst.position(dataEnd).limit(originalLimit);
-
-            return dataEnd - recordStart;
-
-        } catch (Exception e) {
-            throw new RuntimeException("Failed to create record", e);
-        }
+        int keyLen = key.remaining();
+        int valueLen = value.remaining();
+        int checksum = ByteBufferChecksum.crc32(value);
+
+        int recLen = 0;
+        recLen += KEY_LENGTH.set(dst, keyLen);
+        recLen += CHECKSUM.set(dst, checksum);
+        recLen += VALUE_LEN.set(dst, valueLen);
+        recLen += ATTRIBUTE.set(dst, (byte) 0);
+        recLen += TIMESTAMP.set(dst, System.currentTimeMillis());
+        recLen += KEY.set(dst, key);
+        recLen += VALUE.set(dst, value);
+
+        return recLen;
     }
 
     public static int validate(ByteBuffer record) {
@@ -268,4 +264,5 @@ public class Record2 {
         int vSize = valueSize(buffer);
         return ks.fromBytes(buffer.duplicate().limit(vPos + vSize).position(vPos));
     }
+
 }
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/fields/BlobField.java b/indexed-log/src/main/java/io/joshworks/ilog/fields/BlobField.java
new file mode 100644
index 00000000..3bf25b67
--- /dev/null
+++ b/indexed-log/src/main/java/io/joshworks/ilog/fields/BlobField.java
@@ -0,0 +1,32 @@
+package io.joshworks.ilog.fields;
+
+import java.nio.ByteBuffer;
+
+public class BlobField extends Field {
+
+    public BlobField(int offset, int len) {
+        super(b -> offset, b -> len);
+    }
+
+    public BlobField(Mapper offsetSupplier, Mapper lenSupplier) {
+        super(offsetSupplier, lenSupplier);
+    }
+
+    public BlobField(int offset, Mapper lenSupplier) {
+        this(b -> offset, lenSupplier);
+    }
+
+    public static BlobField after(Field field, Mapper offset) {
+        return new BlobField(b -> afterOf(field, b), offset);
+    }
+
+    private static int afterOf(Field field, ByteBuffer b) {
+        int _offset = field.offset.apply(b);
+        int _len = field.len.apply(b);
+        return _offset + _len;
+    }
+
+    public int set(ByteBuffer fieldBuffer, ByteBuffer value) {
+        return super.copyFrom(fieldBuffer, value);
+    }
+}
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/fields/ByteField.java b/indexed-log/src/main/java/io/joshworks/ilog/fields/ByteField.java
new file mode 100644
index 00000000..ffd34239
--- /dev/null
+++ b/indexed-log/src/main/java/io/joshworks/ilog/fields/ByteField.java
@@ -0,0 +1,27 @@
+package io.joshworks.ilog.fields;
+
+import java.nio.ByteBuffer;
+
+import static io.joshworks.fstore.core.io.buffers.Buffers.relativePosition;
+
+public class ByteField extends Field {
+
+    public ByteField(ByteField offsetSupplier) {
+        super(offsetSupplier::get, bb -> Byte.BYTES);
+    }
+
+    public ByteField(int offset) {
+        super(bb -> offset, bb -> Byte.BYTES);
+    }
+
+    public int set(ByteBuffer b, byte val) {
+        int _offset = offset.apply(b);
+        b.put(_offset, val);
+        return Byte.BYTES;
+    }
+
+    public byte get(ByteBuffer b) {
+        int _offset = offset.apply(b);
+        return b.get(relativePosition(b, _offset));
+    }
+}
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/fields/Field.java b/indexed-log/src/main/java/io/joshworks/ilog/fields/Field.java
new file mode 100644
index 00000000..ee119481
--- /dev/null
+++ b/indexed-log/src/main/java/io/joshworks/ilog/fields/Field.java
@@ -0,0 +1,68 @@
+package io.joshworks.ilog.fields;
+
+import io.joshworks.fstore.core.io.buffers.Buffers;
+
+import java.nio.ByteBuffer;
+
+import static io.joshworks.fstore.core.io.buffers.Buffers.relativePosition;
+
+public class Field {
+
+    protected final Mapper offset;
+    protected final Mapper len;
+
+    public Field(Mapper offset, Mapper len) {
+        this.offset = offset;
+        this.len = len;
+    }
+
+    public int copyTo(ByteBuffer thisFieldBuffer, ByteBuffer value) {
+        int _offset = offset.apply(thisFieldBuffer);
+        _offset = relativePosition(thisFieldBuffer, _offset);
+        int _len = len.apply(thisFieldBuffer);
+        if (value.remaining() < _len) {
+            throw new IllegalStateException("Expected at lease " + _len + " from the value buffer");
+        }
+        return Buffers.copy(thisFieldBuffer, _offset, _len, value);
+    }
+
+    public int copyTo(ByteBuffer thisFieldBuffer, ByteBuffer value, Field valueMapper) {
+        int thisLen = len.apply(thisFieldBuffer);
+        int valueLen = valueMapper.len.apply(value);
+        if (thisLen != valueLen) {
+            throw new IllegalArgumentException("Field length mismatch");
+        }
+
+        int thisBufferOffset = offset.apply(thisFieldBuffer);
+        thisBufferOffset = relativePosition(thisFieldBuffer, thisBufferOffset);
+
+        int valueOffset = valueMapper.offset.apply(value);
+        return Buffers.copy(thisFieldBuffer, thisBufferOffset, thisLen, value, valueOffset);
+    }
+
+    public int copyFrom(ByteBuffer thisFieldBuffer, ByteBuffer value) {
+        int _offset = offset.apply(thisFieldBuffer);
+        _offset = relativePosition(thisFieldBuffer, _offset);
+        int _len = len.apply(thisFieldBuffer);
+        if (value.remaining() < _len) {
+            throw new IllegalStateException("Expected at lease " + _len + " from the value buffer");
+        }
+        //_len => copy only the fields size to this buffer to avoid overflow;
+        return Buffers.copy(value, value.position(), _len, thisFieldBuffer, _offset);
+    }
+
+    public int copyFrom(ByteBuffer thisFieldBuffer, ByteBuffer value, Field valueMapper) {
+        int thisLen = len.apply(thisFieldBuffer);
+        int valueLen = valueMapper.len.apply(value);
+        if (thisLen != valueLen) {
+            throw new IllegalArgumentException("Field length mismatch");
+        }
+
+        int thisBufferOffset = offset.apply(thisFieldBuffer);
+        thisBufferOffset = relativePosition(thisFieldBuffer, thisBufferOffset);
+
+        int valueOffset = valueMapper.offset.apply(value);
+        return Buffers.copy(value, valueOffset, valueLen, thisFieldBuffer, thisBufferOffset);
+    }
+
+}
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/fields/IntField.java b/indexed-log/src/main/java/io/joshworks/ilog/fields/IntField.java
new file mode 100644
index 00000000..1ea9b84c
--- /dev/null
+++ b/indexed-log/src/main/java/io/joshworks/ilog/fields/IntField.java
@@ -0,0 +1,27 @@
+package io.joshworks.ilog.fields;
+
+import java.nio.ByteBuffer;
+
+import static io.joshworks.fstore.core.io.buffers.Buffers.relativePosition;
+
+public class IntField extends Field {
+
+    public IntField(IntField offsetSupplier) {
+        super(offsetSupplier::get, bb -> Integer.BYTES);
+    }
+
+    public IntField(int offset) {
+        super(bb -> offset, bb -> Integer.BYTES);
+    }
+
+    public int set(ByteBuffer b, int val) {
+        int _offset = offset.apply(b);
+        b.putInt(_offset, val);
+        return Integer.BYTES;
+    }
+
+    public int get(ByteBuffer b) {
+        int _offset = offset.apply(b);
+        return b.getInt(relativePosition(b, _offset));
+    }
+}
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/fields/LongField.java b/indexed-log/src/main/java/io/joshworks/ilog/fields/LongField.java
new file mode 100644
index 00000000..973823b5
--- /dev/null
+++ b/indexed-log/src/main/java/io/joshworks/ilog/fields/LongField.java
@@ -0,0 +1,23 @@
+package io.joshworks.ilog.fields;
+
+import java.nio.ByteBuffer;
+
+import static io.joshworks.fstore.core.io.buffers.Buffers.relativePosition;
+
+public class LongField extends Field{
+
+    public LongField(int offset) {
+        super(b -> offset, b -> Long.BYTES);
+    }
+
+    public int set(ByteBuffer b, long val) {
+        int _offset = offset.apply(b);
+        b.putLong(_offset, val);
+        return Long.BYTES;
+    }
+
+    public long get(ByteBuffer b) {
+        int _offset = this.offset.apply(b);
+        return b.getLong(relativePosition(b, _offset));
+    }
+}
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/fields/Mapper.java b/indexed-log/src/main/java/io/joshworks/ilog/fields/Mapper.java
new file mode 100644
index 00000000..ceebeff7
--- /dev/null
+++ b/indexed-log/src/main/java/io/joshworks/ilog/fields/Mapper.java
@@ -0,0 +1,9 @@
+package io.joshworks.ilog.fields;
+
+import java.nio.ByteBuffer;
+
+public interface Mapper {
+
+    int apply(ByteBuffer b);
+
+}
diff --git a/indexed-log/src/main/java/io/joshworks/ilog/lsm/MemTable1.java b/indexed-log/src/main/java/io/joshworks/ilog/lsm/MemTable1.java
new file mode 100644
index 00000000..9312a459
--- /dev/null
+++ b/indexed-log/src/main/java/io/joshworks/ilog/lsm/MemTable1.java
@@ -0,0 +1,190 @@
+package io.joshworks.ilog.lsm;
+
+import io.joshworks.fstore.core.codec.Codec;
+import io.joshworks.fstore.core.io.buffers.BufferPool;
+import io.joshworks.fstore.core.io.buffers.Buffers;
+import io.joshworks.ilog.Record2;
+import io.joshworks.ilog.index.IndexFunctions;
+import io.joshworks.ilog.index.KeyComparator;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+import static io.joshworks.ilog.Record2.keyOffset;
+import static io.joshworks.ilog.Record2.keySize;
+import static io.joshworks.ilog.lsm.Block2.keyOverhead;
+import static java.util.Objects.requireNonNull;
+
+class MemTable1 {
+
+    final List<ByteBuffer> table;
+    private final KeyComparator comparator;
+    private final BufferPool recordPool; //used to store records
+    private final AtomicInteger entries = new AtomicInteger();
+    private final AtomicInteger sizeInBytes = new AtomicInteger();
+
+    MemTable1(KeyComparator comparator, int maxEntries, int maxRecordSize) {
+        this.table = new ArrayList<>(maxEntries);
+        this.recordPool = BufferPool.defaultPool(maxEntries, maxRecordSize, true);
+        this.comparator = comparator;
+
+        //pre allocate
+        for (int i = 0; i < maxEntries; i++) {
+            recordPool.free(recordPool.allocate());
+        }
+    }
+
+    void add(ByteBuffer record) {
+        requireNonNull(record, "Record must be provided");
+
+        var memRec = recordPool.allocate();
+        try {
+            Buffers.copy(record, memRec);
+            memRec.flip();
+
+            int keyOffset = keyOffset(memRec);
+            int recordSize = Record2.sizeOf(memRec);
+            int idx = binarySearch(memRec, keyOffset);
+
+            if (idx >= 0) { //existing entry
+                int existingSize = Record2.sizeOf(table.get(idx));
+                table.set(idx, memRec);
+                int diff = recordSize - existingSize;
+                sizeInBytes.addAndGet(diff);
+            } else {
+                table.add(Math.abs(idx) - 1, memRec);
+                entries.incrementAndGet();
+            }
+
+        } catch (Exception e) {
+            throw new RuntimeException("Failed to insert record", e);
+        }
+    }
+
+    public int apply(ByteBuffer key, ByteBuffer dst, IndexFunctions fn) {
+        validateKeySize(key);
+        int idx = binarySearch(key, key.position());
+        idx = fn.apply(idx);
+        if (idx < 0) {
+            return 0;
+        }
+        ByteBuffer record = table.get(idx);
+        return LsmRecord.fromRecord(record, dst);
+    }
+
+    public int size() {
+        return entries.get();
+    }
+
+    private void validateKeySize(ByteBuffer key) {
+        if (key.remaining() != comparator.keySize()) {
+            throw new IllegalArgumentException("Invalid key size: " + key.remaining());
+        }
+    }
+
+    private static ByteBuffer getValue(Map.Entry<ByteBuffer, ByteBuffer> entry) {
+        return entry == null ? null : entry.getValue();
+    }
+
+    long writeTo(Consumer<ByteBuffer> writer, long maxAge, Codec codec, ByteBuffer block, ByteBuffer blockRecords, ByteBuffer dst) {
+        if (table.isEmpty()) {
+            return 0;
+        }
+
+        long inserted = 0;
+        int blockEntries = 0;
+        ByteBuffer first = null;
+        int keyOverhead = keyOverhead(comparator.keySize());
+
+        Buffers.offsetPosition(block, Block2.HEADER_SIZE);
+        for (ByteBuffer record : table) {
+            if (LsmRecord.expired(record, maxAge) && !LsmRecord.deletion(record)) {
+                continue;
+            }
+
+            int valueRegionSize = blockRecords.position();
+            int valueSize = Record2.valueSize(record);
+            int valueOverhead = Block2.Record.valueOverhead(valueSize);
+
+            //not enough space in the block, compress and write
+            if (block.remaining() < valueRegionSize + keyOverhead + valueOverhead) {
+                writeBlock(writer, codec, block, blockRecords, dst, blockEntries, first);
+
+                //reset state
+                blockEntries = 0;
+                first = null;
+
+                //clear buffers
+                block.clear();
+                blockRecords.clear();
+                dst.clear();
+                Buffers.offsetPosition(block, Block2.HEADER_SIZE);
+            }
+
+
+            int offset = blockRecords.position();
+
+            //BLOCK DATA
+            Block2.Record.fromRecord(record, blockRecords);
+
+            //KEYS_REGION
+            Buffers.copy(record, keyOffset(record), keySize(record), block);
+            block.putInt(offset);
+
+            first = first == null ? record : first;
+            blockEntries++;
+            inserted++;
+        }
+        writeBlock(writer, codec, block, blockRecords, dst, blockEntries, first);
+
+        entries.set(0); // TODO remove
+        table.clear(); // TODO remove
+        return inserted;
+    }
+
+    private void writeBlock(Consumer<ByteBuffer> writer, Codec codec, ByteBuffer block, ByteBuffer blockRecords, ByteBuffer dst, int blockEntries, ByteBuffer firstRecord) {
+        blockRecords.flip();
+        int uncompressedSize = blockRecords.remaining();
+
+        if (block.remaining() < uncompressedSize) {
+            throw new IllegalStateException("Not enough space block space");
+        }
+
+        Block2.compress(blockRecords, block, codec);
+        block.flip();
+
+        Block2.writeHeader(block, uncompressedSize, blockEntries);
+
+        Record2.create(firstRecord, block, dst);
+
+
+        dst.flip();
+
+        writer.accept(dst);
+    }
+
+    private int binarySearch(ByteBuffer key, int keyStart) {
+        int entries = table.size();
+
+        int low = 0;
+        int high = entries - 1;
+
+        while (low <= high) {
+            int mid = (low + high) >>> 1;
+            ByteBuffer rec = table.get(mid);
+            int cmp = comparator.compare(rec, 0, key, keyStart);
+            if (cmp < 0)
+                low = mid + 1;
+            else if (cmp > 0)
+                high = mid - 1;
+            else
+                return mid;
+        }
+        return -(low + 1);
+    }
+
+}
diff --git a/indexed-log/src/test/java/io/joshworks/ilog/Record2Test.java b/indexed-log/src/test/java/io/joshworks/ilog/Record2Test.java
index ef95cc2b..31e3f41a 100644
--- a/indexed-log/src/test/java/io/joshworks/ilog/Record2Test.java
+++ b/indexed-log/src/test/java/io/joshworks/ilog/Record2Test.java
@@ -4,14 +4,32 @@ import org.junit.Test;
 
 import java.nio.ByteBuffer;
 
-import static org.junit.Assert.*;
-
 public class Record2Test {
-
-
     @Test
     public void create() {
-        ByteBuffer rec = RecordUtils.create(1, "abcde");
-        int validate = Record2.validate(rec);
+
+        var key = ByteBuffer.allocate(1024).putLong(123).flip();
+        var value = ByteBuffer.allocate(4096).putLong(123).putInt(456).flip();
+        var dst = ByteBuffer.allocate(4096);
+
+        int size = Record2.create(key, value, dst);
+//        Buffers.offsetPosition(dst, size);
+
+
+        var keyCopy = ByteBuffer.allocate(1024);
+        var valCopy = ByteBuffer.allocate(1024);
+
+        int keyLen = Record2.KEY_LENGTH.get(dst);
+        int checksum = Record2.CHECKSUM.get(dst);
+        long timestamp = Record2.TIMESTAMP.get(dst);
+        int valLen = Record2.VALUE_LEN.get(dst);
+        Record2.KEY.copyTo(dst, keyCopy);
+        Record2.VALUE.copyTo(dst, valCopy);
+
+        keyCopy.flip();
+        valCopy.flip();
+
+        System.out.println();
+
     }
 }
\ No newline at end of file
